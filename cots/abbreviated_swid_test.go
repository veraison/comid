// Copyright 2020-2024 Contributors to the Veraison project.
// SPDX-License-Identifier: Apache-2.0

// The tests in this file were copied from softwareidentity_test.go in github.com/veraison/swid with minor edits made
// to the expected results to reflect omission of the TagVersion field.

package cots

import (
	"encoding/xml"
	"reflect"
	"testing"

	"github.com/fxamacker/cbor/v2"
	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
	"github.com/veraison/swid"
)

var (
	testXML  = []byte(`<AbbreviatedSwidTag><Entity name="ACME Ltd" regid="acme.example" role="tagCreator softwareCreator aggregator"></Entity></AbbreviatedSwidTag>`)
	testJSON = []byte(`{
		"entity": [
		  {
			"entity-name": "ACME Ltd",
			"reg-id": "acme.example",
			"role": [
			  "tagCreator",
			  "softwareCreator",
			  "aggregator"
			]
		  }
		]
	}`)
	testCBOR = []byte{
		0xa1, 0x2, 0xa3, 0x18, 0x1f, 0x68, 0x41, 0x43, 0x4d,
		0x45, 0x20, 0x4c, 0x74, 0x64, 0x18, 0x20, 0x6c, 0x61,
		0x63, 0x6d, 0x65, 0x2e, 0x65, 0x78, 0x61, 0x6d, 0x70,
		0x6c, 0x65, 0x18, 0x21, 0x83, 0x1, 0x2, 0x3,
	}
)

func makeACMEEntityWithRoles(t *testing.T, roles ...interface{}) swid.Entity {
	e := swid.Entity{
		EntityName: "ACME Ltd",
		RegID:      "acme.example",
	}

	require.Nil(t, e.SetRoles(roles...))

	return e
}

func TestTag_FromCBOR_ok(t *testing.T) {
	expected := AbbreviatedSwidTag{
		Entities: swid.Entities{
			makeACMEEntityWithRoles(t,
				swid.RoleTagCreator,
				swid.RoleSoftwareCreator,
				swid.RoleAggregator,
			),
		},
	}

	var tv AbbreviatedSwidTag

	err := tv.FromCBOR(testCBOR)
	assert.NoError(t, err)
	assert.Equal(t, expected, tv)
}

func TestTag_FromJSON_ok(t *testing.T) {
	expected := AbbreviatedSwidTag{
		Entities: swid.Entities{
			makeACMEEntityWithRoles(t,
				swid.RoleTagCreator,
				swid.RoleSoftwareCreator,
				swid.RoleAggregator,
			),
		},
	}

	var tv AbbreviatedSwidTag

	err := tv.FromJSON(testJSON)
	assert.NoError(t, err)
	assert.Equal(t, expected, tv)
}

func TestTag_FromXML_ok(t *testing.T) {
	expected := AbbreviatedSwidTag{
		XMLName: xml.Name{
			Local: "AbbreviatedSwidTag",
		},
		Entities: swid.Entities{
			makeACMEEntityWithRoles(t,
				"tagCreator",
				"softwareCreator",
				"aggregator",
			),
		},
	}

	var tv AbbreviatedSwidTag

	err := tv.FromXML(testXML)
	assert.NoError(t, err)
	assert.Equal(t, expected, tv)
}

func TestTag_encodings_ok(t *testing.T) {
	tv := AbbreviatedSwidTag{
		Entities: swid.Entities{
			makeACMEEntityWithRoles(t,
				swid.RoleTagCreator,
				swid.RoleSoftwareCreator,
				swid.RoleAggregator,
			),
		},
	}

	actualCBOR, err := tv.ToCBOR()
	assert.NoError(t, err)
	assert.Equal(t, testCBOR, actualCBOR)

	actualJSON, err := tv.ToJSON()
	assert.NoError(t, err)
	assert.JSONEq(t, string(testJSON), string(actualJSON))

	actualXML, err := tv.ToXML()
	assert.NoError(t, err)
	assert.Equal(t, testXML, actualXML)
}

func TestTag_RoundtripPSABundle(t *testing.T) {
	tv := AbbreviatedSwidTag{
		TagID:           swid.NewTagID("example.acme.roadrunner-sw-v1-0-0"),
		SoftwareName:    "Roadrunner software bundle",
		SoftwareVersion: "1.0.0",
		Entities: swid.Entities{
			makeACMEEntityWithRoles(t,
				swid.RoleTagCreator,
				swid.RoleSoftwareCreator,
				swid.RoleAggregator,
			),
		},
		Links: &swid.Links{
			swid.Link{
				Href: "example.acme.roadrunner-hw-v1-0-0",
				Rel:  *swid.NewRel("psa-rot-compound"),
			},
			swid.Link{
				Href: "example.acme.roadrunner-sw-bl-v1-0-0",
				Rel:  *swid.NewRel(swid.RelComponent),
			},
			swid.Link{
				Href: "example.acme.roadrunner-sw-prot-v1-0-0",
				Rel:  *swid.NewRel(swid.RelComponent),
			},
			swid.Link{
				Href: "example.acme.roadrunner-sw-arot-v1-0-0",
				Rel:  *swid.NewRel(swid.RelComponent),
			},
		},
	}

	expectedCBOR := []byte{
		0xa5, 0x00, 0x78, 0x21, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e,
		0x61, 0x63, 0x6d, 0x65, 0x2e, 0x72, 0x6f, 0x61, 0x64, 0x72, 0x75, 0x6e,
		0x6e, 0x65, 0x72, 0x2d, 0x73, 0x77, 0x2d, 0x76, 0x31, 0x2d, 0x30, 0x2d,
		0x30, 0x01, 0x78, 0x1a, 0x52, 0x6f, 0x61, 0x64, 0x72, 0x75,
		0x6e, 0x6e, 0x65, 0x72, 0x20, 0x73, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72,
		0x65, 0x20, 0x62, 0x75, 0x6e, 0x64, 0x6c, 0x65, 0x0d, 0x65, 0x31, 0x2e,
		0x30, 0x2e, 0x30, 0x02, 0xa3, 0x18, 0x1f, 0x68, 0x41, 0x43, 0x4d, 0x45,
		0x20, 0x4c, 0x74, 0x64, 0x18, 0x20, 0x6c, 0x61, 0x63, 0x6d, 0x65, 0x2e,
		0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x18, 0x21, 0x83, 0x01, 0x02,
		0x03, 0x04, 0x84, 0xa2, 0x18, 0x26, 0x78, 0x21, 0x65, 0x78, 0x61, 0x6d,
		0x70, 0x6c, 0x65, 0x2e, 0x61, 0x63, 0x6d, 0x65, 0x2e, 0x72, 0x6f, 0x61,
		0x64, 0x72, 0x75, 0x6e, 0x6e, 0x65, 0x72, 0x2d, 0x68, 0x77, 0x2d, 0x76,
		0x31, 0x2d, 0x30, 0x2d, 0x30, 0x18, 0x28, 0x70, 0x70, 0x73, 0x61, 0x2d,
		0x72, 0x6f, 0x74, 0x2d, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x75, 0x6e, 0x64,
		0xa2, 0x18, 0x26, 0x78, 0x24, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
		0x2e, 0x61, 0x63, 0x6d, 0x65, 0x2e, 0x72, 0x6f, 0x61, 0x64, 0x72, 0x75,
		0x6e, 0x6e, 0x65, 0x72, 0x2d, 0x73, 0x77, 0x2d, 0x62, 0x6c, 0x2d, 0x76,
		0x31, 0x2d, 0x30, 0x2d, 0x30, 0x18, 0x28, 0x02, 0xa2, 0x18, 0x26, 0x78,
		0x26, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x61, 0x63, 0x6d,
		0x65, 0x2e, 0x72, 0x6f, 0x61, 0x64, 0x72, 0x75, 0x6e, 0x6e, 0x65, 0x72,
		0x2d, 0x73, 0x77, 0x2d, 0x70, 0x72, 0x6f, 0x74, 0x2d, 0x76, 0x31, 0x2d,
		0x30, 0x2d, 0x30, 0x18, 0x28, 0x02, 0xa2, 0x18, 0x26, 0x78, 0x26, 0x65,
		0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x61, 0x63, 0x6d, 0x65, 0x2e,
		0x72, 0x6f, 0x61, 0x64, 0x72, 0x75, 0x6e, 0x6e, 0x65, 0x72, 0x2d, 0x73,
		0x77, 0x2d, 0x61, 0x72, 0x6f, 0x74, 0x2d, 0x76, 0x31, 0x2d, 0x30, 0x2d,
		0x30, 0x18, 0x28, 0x02,
	}

	roundTripper(t, tv, expectedCBOR)
}

// marshal + unmarshal
func roundTripper(t *testing.T, tv interface{}, expectedCBOR []byte) interface{} {
	encMode, err := cbor.EncOptions{TimeTag: cbor.EncTagRequired}.EncMode()
	require.Nil(t, err)

	data, err := encMode.Marshal(tv)

	assert.Nil(t, err)
	t.Logf("CBOR(hex): %x\n", data)
	assert.Equal(t, expectedCBOR, data)

	decMode, err := cbor.DecOptions{TimeTag: cbor.DecTagOptional}.DecMode()
	require.Nil(t, err)

	actual := reflect.New(reflect.TypeOf(tv))
	err = decMode.Unmarshal(data, actual.Interface())

	assert.Nil(t, err)
	assert.Equal(t, tv, actual.Elem().Interface())

	// Return the an interface wrapping the roundtripped test vector.
	// In case it's needed for further processing it can be extracted
	// with a type assertion.
	return actual.Elem().Interface()
}
